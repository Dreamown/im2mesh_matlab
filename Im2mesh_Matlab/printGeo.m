function printGeo( C, point, line, opt, path_file_name )
% printGeo: write geometry data (surface) into geo file (Gmsh input file format)
%
% input:
% C is a nesting cell array for storing multiple loops. C is a 1-by-P cell 
%   array. C{i} means the i-th physical surface. C{i} is a 1-by-S cell 
%   array. C{i}{j} means the j-th plane surface within the i-th physical 
%   surface. C{i}{j} is 1-by-L cell array. C{i}{j}{k} means the k-th loop 
%   of the j-th plane surface within the i-th physical surface. C{i}{j}{k} 
%   stores the line indices within a loop. C{i}{j}{k} is an N-by-1 array.
%
%  point - V-by-2 array. x,y coordinates of vertices. 
%           Each row is one vertex.
%
%  line - E-by-2 array. Node numbering of two connecting vertices of
%           edges. Each row is one edge.
%
%  path_file_name - file name of geo file, e.g. 'gmshTemp.geo'
%
%
% Example:
%     [ phaseLoops, point, line ] = bound2SurfaceLoop( bounds );
%     
%     % setup parameters (10 parameters in total)
%     opt = [];
%     opt.sizeMin = 0.1;
%     opt.sizeMax = 50;
%     opt.algthm = 6;
%     opt.recombAll = 0;
%     opt.recombAlgthm = 3;
%     opt.eleOrder = 1;
%     opt.scalingFactor = 1;
%     opt.tf_gradient = false;
%     opt.sizeAtBound = 1.5;
%     opt.sizeSlope = 0.2;
%     
%     path_to_geo = 'gmshTemp.geo';
%     printGeo( phaseLoops, point, line, opt, path_to_geo );
%
%
% Im2mesh is copyright (C) 2019-2025 by Jiexian Ma and is distributed under
% the terms of the GNU General Public License (version 3).
% 
% Project website: https://github.com/mjx888/im2mesh
%

    %---------------------------------------------------------------------
    % verify field names and set values for opt
    opt = setOption( opt );

    %---------------------------------------------------------------------
    % Open a file for writing
    fid = fopen(path_file_name, 'wW');
    
    %---------------------------------------------------------------------
    fprintf(fid, '// Gmsh input file generated by Im2mesh package. \n');
    fprintf(fid, '\n');
    % ---------------------------
    % 1. Print out the Points
    % ---------------------------
    for i = 1:size(point, 1)
        x = point(i, 1);
        y = point(i, 2);
        % Gmsh syntax: Point(ID) = {x, y, z, lc};
        fprintf(fid, 'Point(%d) = {%.6f, %.6f, 0};\n', ...
                i, x, y );
    end
    fprintf(fid, '\n');
    
    % ---------------------------
    % 2. Print out the Lines
    % ---------------------------
    for i = 1:size(line, 1)
        p1 = line(i, 1);
        p2 = line(i, 2);
        % Gmsh syntax: Line(ID) = {startPt, endPt};
        fprintf(fid, 'Line(%d) = {%d, %d};\n', i, p1, p2);
    end
    fprintf(fid, '\n');
    
    fprintf(fid, '//----------------------------------------\n');
    fprintf(fid, '\n');
    %---------------------------------------------------------------------
    % Initialize counters for Gmsh IDs
    phyID    = 1;  % Physical surface ID
    surfaceID = 1; % Plane surface ID
    loopID   = 1;  % Line loop ID
    
    % Loop over each physical surface
    for i = 1:numel(C)
        % We will collect the plane surfaces (their IDs) that go into this physical surface
        surfacesInThisPhysical = [];
        
        % Each C{i} is a cell array of plane surfaces
        for j = 1:numel(C{i})
            
            % We will collect the loop IDs in this plane surface
            loopsInThisSurface = [];
            
            % Each C{i}{j} is a cell array of loops
            for k = 1:numel(C{i}{j})
                lineIndices = C{i}{j}{k};  % Nx1 array of line indices for the k-th loop
                
                % -------------------------------
                % 1. Print the Line Loop
                % -------------------------------
                % Gmsh syntax: Line Loop(loopID) = {line1, line2, ...};
                fprintf(fid, 'Line Loop(%d) = {', loopID);
                % Print each line index, separated by commas
                for n = 1:numel(lineIndices)
                    if n == numel(lineIndices)
                        fprintf(fid, '%d};\n', lineIndices(n));
                    else
                        fprintf(fid, '%d, ', lineIndices(n));
                    end
                end
                
                % Store this loop ID so we can reference it in the plane surface
                loopsInThisSurface = [loopsInThisSurface, loopID];
                loopID = loopID + 1;
                
            end % k
            
            % -------------------------------
            % 2. Print the Plane Surface
            % -------------------------------
            % A plane surface can have one or more loops: the first is the outer boundary,
            % and subsequent loops can be holes (with negative sign in advanced usage).
            % But here we assume each plane surface uses all the loops in loopsInThisSurface.
            
            % Gmsh syntax: Plane Surface(surfaceID) = {loop1, loop2, ...};
            fprintf(fid, 'Plane Surface(%d) = {', surfaceID);
            for u = 1:numel(loopsInThisSurface)
                if u == numel(loopsInThisSurface)
                    fprintf(fid, '%d};\n', loopsInThisSurface(u));
                else
                    fprintf(fid, '%d, ', loopsInThisSurface(u));
                end
            end
            fprintf(fid, '\n');

            % Store this surface ID so we can reference it in the physical surface
            surfacesInThisPhysical = [surfacesInThisPhysical, surfaceID];
            surfaceID = surfaceID + 1;
            
        end % j
        
        % -------------------------------
        % 3. Print the Physical Surface
        % -------------------------------
        % Gmsh syntax: Physical Surface(phyID) = {surface1, surface2, ...};
        
        fprintf(fid, 'Physical Surface(%d) = {', phyID);
        for v = 1:numel(surfacesInThisPhysical)
            if v == numel(surfacesInThisPhysical)
                fprintf(fid, '%d};\n', surfacesInThisPhysical(v));
            else
                fprintf(fid, '%d, ', surfacesInThisPhysical(v));
            end
        end
        fprintf(fid, '\n');
        fprintf(fid, '//----------------------------------------\n');
        fprintf(fid, '\n');

        phyID = phyID + 1;
        
    end % i

    %---------------------------------------------------------------------
    fprintf(fid, '// Mesh \n');
    fprintf(fid, 'Mesh.ScalingFactor = %.8f;\n',    opt.scalingFactor );
    fprintf(fid, '\n');

    if opt.tf_includeMesh == true
        fprintf(fid, 'Mesh.MeshSizeMin = %.3f;\n',            opt.sizeMin );
        fprintf(fid, 'Mesh.MeshSizeMax = %.3f;\n',            opt.sizeMax );
        fprintf(fid, 'Mesh.Algorithm = %d;\n',                opt.algthm );
        fprintf(fid, 'Mesh.RecombineAll = %d;\n',             opt.recombAll );
        fprintf(fid, 'Mesh.RecombinationAlgorithm = %d;\n',   opt.recombAlgthm );
        fprintf(fid, 'Mesh.ElementOrder = %d;\n',             opt.eleOrder );
        fprintf(fid, '\n');

        if opt.tf_gradient == true
            fprintf(fid, 'Field[1] = Distance;\n');
            fprintf(fid, 'Field[1].EdgesList = {1:%d};\n', size(line,1) );
            fprintf(fid, 'Field[2] = MathEval;\n');
            fprintf(fid, 'Field[2].F = "F1 * %.4f + %.4f";\n', opt.sizeSlope, opt.sizeAtBound );
            fprintf(fid, 'Background Field = 2;\n');
            fprintf(fid, '\n');
    
            fprintf(fid, 'Mesh.MeshSizeExtendFromBoundary = 0;\n');
            fprintf(fid, 'Mesh.MeshSizeFromPoints = 0;\n');
            fprintf(fid, 'Mesh.MeshSizeFromCurvature = 0;\n');
        end
        
        fprintf(fid, '\n');
        fprintf(fid, 'Mesh 2;\n');
        fprintf(fid, '\n');
    end

    %---------------------------------------------------------------------
    fprintf(fid, '// set format\n');
    fprintf(fid, 'Mesh.Format=10;\n');
    fprintf(fid, '\n');
    
    %---------------------------------------------------------------------
    fprintf(fid, '// End of geo file\n');
    
    fclose(fid);

    disp('printGeo Done! Check the geo file!');
    %---------------------------------------------------------------------
end


function new_opt = setOption( opt )
% setOption: verify field names in opt and set values in new_opt according
% to opt

    % initialize new_opt with default field names & value 
    new_opt.sizeMin = 0.1;
    new_opt.sizeMax = 50;
    new_opt.algthm = 6;
    new_opt.recombAll = 0;
    new_opt.recombAlgthm = 3;
    new_opt.eleOrder = 1;
    new_opt.scalingFactor = 1;

    new_opt.tf_gradient = false;
    new_opt.sizeAtBound = 1.5;
    new_opt.sizeSlope = 0.2;

    new_opt.tf_includeMesh = true;


    if isempty(opt)
        return
    end

    if ~isstruct(opt)
        error("opt is not a structure array. Not valid input.")
    end

    % get the field names of opt
    nameC = fieldnames(opt);

    % verify field names in opt and set values in new_opt
    % compare the field name of opt with new_opt using for loop
    % if a field name of opt exist in new_opt, assign the that field value 
    % in opt to new_opt
    % if a field name of opt not exist in new_opt, show error

    for i = 1: length(nameC)
        if isfield( new_opt, nameC{i} )
            value = getfield( opt, nameC{i} );
            new_opt = setfield( new_opt, nameC{i}, value );
        else
            error("Field name %s in opt is not correct.", nameC{i});
        end
    end

end












